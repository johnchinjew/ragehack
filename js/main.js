'use strict';

addEventListener("load", function () {
  return terminal.init(document.getElementById('terminal'), filler, 3);
});
addEventListener('keydown', function (e) {
  return terminal.hack(e);
});
addEventListener('mousedown', function (e) {
  return terminal.hack(e);
});

var filler = "/**\n\tThis is RAGE HACK!\n\tMade by John Chin-Jew!!\n\tThe FASTER you type the CRAZIER it gets!!!\n*/\n\npackage binsearch;\n\n/**\n\tA class for executing binary searches through an array.\n*/\npublic class BinarySearcher\n{\n\tprivate int[] a;\n\n\t/**\n\t\tConstructs a BinarySearcher.\n\t\t@param anArray a sorted array of integers\n\t*/\n\tpublic BinarySearcher(int[] anArray)\n\t{\n\t\ta = anArray;\n\t}\n\n\t/**\n\t\tFinds a value in a sorted array, using the binary\n\t\tsearch algorithm.\n\n\t\t@param v the value to search\n\t\t@return the index at which the value occurs, or -1\n\t\tif it does not occur in the array\n\t*/\n\tpublic int search(int v)\n\t{\n\t\tint low = 0;\n\t\tint high = a.length - 1;\n\n\t\twhile (low <= high)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tint diff = a[mid] - v;\n\n\t\t\tif (diff == 0)\t// a[mid] == v\n\t\t\t\treturn mid;\n\n\t\t\telse if (diff < 0) // a[mid] < v\n\t\t\t\tlow = mid + 1;\n\n\t\t\telse\n\t\t\t\thigh = mid - 1;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\npackage insertionsort;\n\n/**\n\tThis class sorts an array, using the insertion sort\n\talgorithm\n*/\npublic class InsertionSorter\n{\n\tprivate int[] a;\n\n\t/**\n\t\tConstructs an insertion sorter.\n\t\t@param anArray the array to sort\n\t*/\n\tpublic InsertionSorter(int[] anArray)\n\t{\n\t\ta = anArray;\n\t}\n\n\t/**\n\t\tSorts the array managed by this insertion sorter\n\t*/\n\tpublic void sort()\n\t{\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t{\n\t\t\tint next = a[i];\n\n\t\t\t// Move all larger elements up\n\t\t\tint j = i;\n\n\t\t\twhile (j > 0 && a[j - 1] > next)\n\t\t\t{\n\t\t\t\ta[j] = a[j - 1];\n\t\t\t\tj--;\n\t\t\t}\n\n\t\t\t// Insert the element\n\t\t\ta[j] = next;\n\t\t}\n\t}\n}\n\npackage linsearch;\n\n/**\n\tA class for executing linear searches through an array.\n*/\npublic class LinearSearcher\n{\n\tprivate int[] a;\n\n\t/**\n\t\tConstructs the LinearSearcher.\n\t\t@param anArray an array of integers\n\t*/\n\tpublic LinearSearcher(int[] anArray)\n\t{\n\t\ta = anArray;\n\t}\n\n\t/**\n\t\tFinds a value in an array, using the linear search\n\t\talgorithm.\n\n\t\t@param v the value to search\n\t\t@return the index at which the value occurs, or -1\n\t\tif it does not occur in the array\n\t*/\n\tpublic int search(int v)\n\t{\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t{\n\t\t\tif (a[i] == v)\n\t\t\t\treturn i;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\npackage mergesort;\n\n/**\n\tThis class sorts an array, using the merge sort algorithm.\n*/\npublic class MergeSorter\n{\n\tprivate int[] a;\n\n\t/**\n\t\tConstructs a merge sorter.\n\t\t@param anArray the array to sort\n\t*/\n\tpublic MergeSorter(int[] anArray)\n\t{\n\t\ta = anArray;\n\t}\n\n\t/**\n\t\tSorts the array managed by this merge sorter.\n\t*/\n\tpublic void sort()\n\t{\n\t\tif (a.length <= 1) return;\n\n\t\tint[] first = new int[a.length / 2];\n\t\tint[] second = new int[a.length - first.length];\n\n\t\t// Copy the first half of a into first, the second half into second\n\t\tfor (int i = 0; i < first.length; i++) { first[i] = a[i]; }\n\n\t\tfor (int i = 0; i < second.length; i++)\n\t\t{\n\t\t\tsecond[i] = a[first.length + i];\n\t\t}\n\n\t\tMergeSorter firstSorter = new MergeSorter(first);\n\t\tMergeSorter secondSorter = new MergeSorter(second);\n\n\t\tfirstSorter.sort();\n\t\tsecondSorter.sort();\n\t\tmerge(first, second);\n\t}\n\n\t/**\n\t\tMerges two sorted arrays into the array managed by this merge sorter.\n\n\t\t@param first the first sorted array\n\t\t@param second the second sorted array\n\t*/\n\tprivate void merge(int[] first, int[] second)\n\t{\n\t\tint iFirst = 0;  // Next element to consider in the first array\n\t\tint iSecond = 0; // Next element to consider in the second array\n\t\tint j = 0;\t  // Next open position in a\n\n\t\t// As long as neither iFirst nor iSecond is past the end, move\n\t\t// the smaller element into a\n\t\twhile (iFirst < first.length && iSecond < second.length)\n\t\t{\n\t\t\tif (first[iFirst] < second[iSecond])\n\t\t\t{\n\t\t\t\ta[j] = first[iFirst];\n\t\t\t\tiFirst++;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[j] = second[iSecond];\n\t\t\t\tiSecond++;\n\t\t\t}\n\t\t}\n\n\t\tj++;\n\t}\n\n\t\t// Note: Only one of the two loops below copies entries\n\t\t// Copy any remaining entries of the first array\n\t\twhile (iFirst < first.length)\n\t\t{\n\t\t\ta[j] = first[iFirst];\n\t\t\tiFirst++; j++;\n\t\t}\n\n\t\t// Copy any remaining entries of the second half\n\t\twhile (iSecond < second.length)\n\t\t{\n\t\t\ta[j] = second[iSecond];\n\t\t\tiSecond++; j++;\n\t\t}\n\t}\n}\n";
